## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫

1. Hash(雜湊)  
    特點
    - 無論原文的內容長短，透過雜湊演算法運算完的輸出都會是固定的長度，即輸出的長度不受原文長度影響。
    - 雜湊演算法的輸出又被稱做「雜湊值」（hash value）。
    - 不同雜湊演算法的輸出長度不同。
    - 兩個原文的內容即便只差一個字，雜湊演算法產生的兩個輸出內容卻會差非常多。
    - 相同的內容作為相同雜湊演算法的輸入，得到的輸出必定一樣。
    - 不同的內容作為相同雜湊演算法的輸入，得到的相同輸出的機率極低。
    - 無法將雜湊演算法的輸出解回原本的輸入，雜湊是單向的。

    用途：運用在不需要被還原的資料，也就是**為什麼密碼要雜湊過後才存入資料庫**

    - 避免明文儲存使用者密碼

      1. 避免資料庫外洩，攻擊者能夠部用運算直接獲得明文密碼。
      2. 尊重使用者，正常狀況下只有使用者知道自己的密碼。

2. Encryption(加密)
    特點
    - 產生一個新的字串作為密鑰
    - 原文與密鑰作為加密演算法的輸入，得到的輸出即為加密過後的密文。
    - 密鑰如果太簡單，很快就被解密了
    - 沒有密鑰就打不開密文，有的話就能得知密文

### 結論  

1. 資料能不能被還原(可不可逆)
2. 雜湊本身基本上不具加密功能，它只能算是具有確認資料正確性的功能

## `include`、`require`、`include_once`、`require_once` 的差別

include 跟 require 都是將檔案引入的功能，但是在報錯與使用條件上還是有一些些微的差異。

- require 在引入時，是無條件引入，不管條件式是否成立都會匯入檔案，且若有錯誤則會給出提示，並停止運行後續程式碼
- include 則是在條件是成立時，才會匯入檔案，若有錯誤，會給出提示，但繼續運行後續程式碼。

>> 兩者後面接 once 則是會檢查檔案是否匯入過，再匯入，若已經匯入則會避免程式重複匯入。

## 請說明 SQL Injection 的攻擊原理以及防範方法

在網路中有許多需要存取資料庫的時機，但由於輸入是使用者來輸入，如果遇到居心不良的使用者，在輸入的同時摻雜 SQL 的指令，當這些資料被傳輸到後端後，若沒有做好防範，指令就會被執行，導致資料庫的資料安全產生問題，發生非預期的資料外洩或 Table 結構遭到破壞等等。  

### 攻擊示範

1. Authorization Bypass：

  ```php
  "SELECT * FROM customers WHERE name =' -name- ' AND password = ' -password-'
  ```

  惡意使用者透過在' -name- '所對應的方塊內輸入

  ```php
  'OR 1=1 --
  ```

  | 語法 | 意義                            |
  |------|-------------------------------|
  | '    | 是將 name 的 input 方塊內容關閉 |
  | OR   | 是指或是的條件                  |
  | 1=1  | 恆正                            |
  | --   | 將後方接著的內容註解化          |

  整段會變成

  ```php
  "SELECT * FROM customers WHERE name =''OR 1=1
  ```

  後段 -- AND password = ' -password-' 變成註解後將不被執行，而前段條件式因加入了 OR 1=1 使得攻擊者可以在不被驗證帳號密碼前提下登入 DataBase。  

### 預防方法

方法：將SQL指令與使用者輸入的資料藉由 PreparedStatement 來分開處理

```php
  $sql = "SELECT * FROM customers WHERE name = ? AND password = ? ";
  $stmt = $conn->prepare($sql);
  $stmt->bind_param("ss", $name, $password);
  $result = $stmt->execute();
  ```

可以看到在查詢參數部分，我們用 ? 來表示，並且透過 bind_param 來指定引數的型別，降低 SQL injection 的風險。

- bind_param 型別

  | 字母 | 型別                 |
  |------|--------------------|
  | i    | integer（整型）        |
  | d    | double（雙精度浮點型） |
  | s    | string（字串）         |
  | b    | BLOB（布林值）         |

## 請說明 XSS 的攻擊原理以及防範方法

XSS 全稱為 Cross-Site Scripting，可翻譯為跨網站指令碼攻擊。本質與 SQL injection 相似，讓使用者的資料成為程式的一部分，來被執行。  
通常是透過 JS 的語法，且網頁有 輸出此內容 的時候，就可以竄改網頁或竊取資料。

1. Stored XSS (儲存型)  

- 網址列看不出問題。
- 最常見的例子就是論壇文章、網站留言板或是訊息，因為使用者可以留任何訊息。
- 資料會被保存在資料庫裏面，所以每個使用者打開都會看到被修改的內容。  
    例如在留言板輸入，使每個人都會中招。

    ```JS
    <script>alert("XSS攻擊測試");</script>
    ```

2. Reflected XSS (反射型)

- 不會被儲存在資料庫中
- 由網頁後端直接嵌入由惡意使用者所傳送過來的內容
- 透過修改網址列上的 GET 參數，來達到惡意程式的目的，所以網址通常都會很奇怪。

3. DOM-Based XSS

- 指網頁上的 JavaScript 在執行過程中，沒有詳細檢查資料使得操作 DOM 的過程代入了惡意指令。
- 輸入任意的內容都會被建立成有效的 DOM 物件

### 預防方法

方法：輸出跳脫字元

```PHP
// php 跳脫字元的內建函式 htmlspecialchars
echo htmlspecialchars($str, ENT_QUOTES, 'utf-8')
// 輸出時需要 encoding
& --> &amp;
< --> &lt;
> --> &gt;
" --> &quot;
' --> &#x27;     
/ --> &#x2F;
```

## 請說明 CSRF 的攻擊原理以及防範方法

CSRF 全名為 Cross-site request forgery，駭客透過欺騙使用者的瀏覽器，取得過去曾經存取過網站的信任，發起惡意操作。  
例如：駭客提供 A 網站連結，點了之後利用**隱藏圖片**或**隱藏表單**，發送 request 至 B 網站，如果你過去已經造訪過 B 網站也在登入狀態，而 B 網站的驗證機制又不足，很有可能會認為 request 為本人發出，會造成很危險的狀況。假如 B 網站 換作是網路銀行，嚴重點很有可能就會默默帳戶就沒錢了（錢被 A 網站的 request 轉走了）

### 預防方法

1. 運用瀏覽器本身提供的防禦機制在Cookie中加入SameSite，跨站請求時，就不會送上Cookie（Session Id預設使用Cookie傳遞）。

>> 所以某些網站會準備兩種 cookie，一般瀏覽網頁時、帶上沒有 samesite 的 Cookie。  
當使用者有敏感操作（如：購買、帳戶…等），會帶上 SameSite=strict 的 Cookie，所以如果從外部網站發 B 網站的 request 就會要求重新登入，讓攻擊者無法 CSRF

2. 利用攻擊者無法直接竊取到用戶的資訊（Cookie，Header，網站內容等），僅僅是冒用Cookie中的資訊的特點，可以要求所有的使用者請求都攜帶一個CSRF攻擊者無法獲取到的Token。 伺服器透過檢查 request 是否攜帶正確的 Token，來把正常的請求和攻擊的請求區分開，也可以防範CSRF的攻擊。
